package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"errors"
	"fmt"
	"quizfreely/api/auth"
	"quizfreely/api/graph/loader"
	"quizfreely/api/graph/model"
	"strings"

	"github.com/georgysavva/scany/v2/pgxscan"
	pgx "github.com/jackc/pgx/v5"
)

// CreateStudyset is the resolver for the createStudyset field.
func (r *mutationResolver) CreateStudyset(ctx context.Context, studyset model.StudysetInput, terms []*model.NewTermInput) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	title := "Untitled Studyset"
	if len(studyset.Title) > 0 && len(studyset.Title) < 200 && validTitleRegex.MatchString(studyset.Title) {
		title = studyset.Title
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	sql := `
		INSERT INTO public.studysets (user_id, title, private)
		VALUES ($1, $2, $3)
		RETURNING id, user_id, title, private,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
	`
	var newStudyset model.Studyset
	err = pgxscan.Get(ctx, tx, &newStudyset, sql, authedUser.ID, title, studyset.Private)
	if err != nil {
		return nil, fmt.Errorf("failed to create studyset: %w", err)
	}

	if terms != nil && len(terms) > 0 {
		values := make([]interface{}, 0, len(terms)*4)
		placeholders := make([]string, 0, len(terms))

		for i, t := range terms {
			placeholders = append(placeholders, fmt.Sprintf("($%d,$%d,$%d,$%d)", i*4+1, i*4+2, i*4+3, i*4+4))
			values = append(values, newStudyset.ID, t.Term, t.Def, t.SortOrder)
		}

		sql := fmt.Sprintf("INSERT INTO terms (studyset_id, term, def, sort_order) VALUES %s", strings.Join(placeholders, ","))
		_, err := tx.Exec(ctx, sql, values...)
		if err != nil {
			return nil, fmt.Errorf("failed to insert terms: %w", err)
		}
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &newStudyset, nil
}

// UpdateStudyset is the resolver for the updateStudyset field.
func (r *mutationResolver) UpdateStudyset(ctx context.Context, id string, studyset *model.StudysetInput, terms []*model.TermInput, newTerms []*model.NewTermInput, deleteTerms []*string) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if studyset == nil && (terms == nil || len(terms) == 0) {
		return r.Query().Studyset(ctx, id)
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var updatedStudyset model.Studyset
	if studyset != nil {
		title := "Untitled Studyset"
		if len(studyset.Title) > 0 && len(studyset.Title) < 200 && validTitleRegex.MatchString(studyset.Title) {
			title = studyset.Title
		}

		sql := `
			UPDATE public.studysets
			SET title = $1, private = $2, updated_at = now()
			WHERE id = $3 AND user_id = $4
			RETURNING id, user_id, title, private,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		`
		err = pgxscan.Get(ctx, tx, &updatedStudyset, sql, title, studyset.Private, id, authedUser.ID)
		if err != nil {
			if pgxscan.NotFound(err) {
				return nil, fmt.Errorf("studyset not found")
			}
			return nil, fmt.Errorf("failed to update studyset: %w", err)
		}
	} else {
		sql := `
			UPDATE public.studysets
			SET updated_at = now()
			WHERE id = $1 AND user_id = $2
			RETURNING id, user_id, title, private,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		`
		err = pgxscan.Get(ctx, tx, &updatedStudyset, sql, id, authedUser.ID)
		if err != nil {
			if pgxscan.NotFound(err) {
				return nil, fmt.Errorf("studyset not found")
			}
			return nil, fmt.Errorf("failed to update studyset: %w", err)
		}
	}

	if terms != nil && len(terms) > 0 {
		values := make([]interface{}, 0, len(terms)*4)
		placeholders := make([]string, 0, len(terms))

		for i, t := range terms {
			placeholders = append(placeholders, fmt.Sprintf(
				"($%d::uuid, $%d::text, $%d::text, $%d::int)",
				i*4+1, i*4+2, i*4+3, i*4+4,
			))
			values = append(values, t.ID, t.Term, t.Def, t.SortOrder)
		}

		sql := fmt.Sprintf(
			`UPDATE terms AS t
			SET term = v.term, def = v.def, sort_order = v.sort_order, updated_at = now()
			FROM (VALUES
				%s
			) AS v(id, term, def, sort_order)
			WHERE t.id = v.id`,
			strings.Join(placeholders, ","),
		)
		_, err := tx.Exec(ctx, sql, values...)
		if err != nil {
			return nil, fmt.Errorf("failed to update terms: %w", err)
		}
	}

	if newTerms != nil && len(newTerms) > 0 {
		values := make([]interface{}, 0, len(newTerms)*4)
		placeholders := make([]string, 0, len(newTerms))

		for i, t := range newTerms {
			placeholders = append(placeholders, fmt.Sprintf("($%d,$%d,$%d,$%d)", i*4+1, i*4+2, i*4+3, i*4+4))
			values = append(values, id, t.Term, t.Def, t.SortOrder)
		}

		sql := fmt.Sprintf("INSERT INTO terms (studyset_id, term, def, sort_order) VALUES %s", strings.Join(placeholders, ","))
		_, err := tx.Exec(ctx, sql, values...)
		if err != nil {
			return nil, fmt.Errorf("failed to insert new terms: %w", err)
		}
	}

	if deleteTerms != nil && len(deleteTerms) > 0 {
		_, err := tx.Exec(
			ctx,
			"DELETE FROM terms WHERE id = ANY($1) AND studyset_id = $2",
			deleteTerms,
			id,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to delete terms: %w", err)
		}
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &updatedStudyset, nil
}

// DeleteStudyset is the resolver for the deleteStudyset field.
func (r *mutationResolver) DeleteStudyset(ctx context.Context, id string) (*string, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	var deletedID string
	err := r.DB.QueryRow(ctx, "DELETE FROM public.studysets WHERE id = $1 AND user_id = $2 RETURNING id", id, authedUser.ID).Scan(&deletedID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("studyset not found")
		}
		return nil, fmt.Errorf("failed to delete studyset: %w", err)
	}

	return &deletedID, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, displayName *string) (*model.AuthedUser, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if displayName != nil {
		trimmedDisplayName := strings.TrimSpace(*displayName)
		if len(trimmedDisplayName) < 1 || len(trimmedDisplayName) > 32 {
			return nil, fmt.Errorf("display name must be between 1 and 32 characters")
		}
		if *displayName != trimmedDisplayName {
			return nil, fmt.Errorf("display name must not have leading or trailing whitespace")
		}
	} else {
		return authedUser, nil
	}

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var updatedUser model.AuthedUser
	err = pgxscan.Get(ctx, tx, &updatedUser,
		`UPDATE auth.users SET display_name = $1 WHERE id = $2 RETURNING id, display_name`,
		*displayName, authedUser.ID)

	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return &updatedUser, nil
}

// UpdateTermProgress is the resolver for the updateTermProgress field.
func (r *mutationResolver) UpdateTermProgress(ctx context.Context, termID string, progress model.TermProgressInput) (*model.TermProgress, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	var termProgress model.TermProgress
	err := pgxscan.Get(
		ctx,
		r.DB,
		&termProgress,
		`INSERT INTO term_progress (
    term_id, user_id,
    term_first_reviewed_at, term_last_reviewed_at,
	term_review_count,
    def_first_reviewed_at, def_last_reviewed_at,
	def_review_count,
    term_leitner_system_box, def_leitner_system_box,
	term_correct_count, term_incorrect_count,
	def_correct_count, def_incorrect_count
) VALUES (
    $1, $2,
	$3::timestamptz, $3::timestamptz,
    CASE WHEN $3 IS NOT NULL THEN 1 ELSE 0 END,
	$4::timestamptz, $4::timestamptz,
    CASE WHEN $4 IS NOT NULL THEN 1 ELSE 0 END,
    $5, $6,
	COALESCE($7, 0), COALESCE($8, 0),
	COALESCE($9, 0), COALESCE($10, 0)
) ON CONFLICT (term_id, user_id) DO UPDATE SET
	term_last_reviewed_at = COALESCE(
		$3::timestamptz, term_progress.term_last_reviewed_at
	),
	def_last_reviewed_at = COALESCE(
		$4::timestamptz, term_progress.def_last_reviewed_at
	),
    term_leitner_system_box = $5,
    def_leitner_system_box = $6,
    term_review_count = term_progress.term_review_count + 
        (CASE WHEN $3 IS NOT NULL THEN 1 ELSE 0 END),
    def_review_count = term_progress.def_review_count + 
        (CASE WHEN $4 IS NOT NULL THEN 1 ELSE 0 END),
	term_correct_count = term_progress.term_correct_count +
		COALESCE($7, 0),
	term_incorrect_count = term_progress.term_incorrect_count +
		COALESCE($8, 0),
	def_correct_count = term_progress.def_correct_count +
		COALESCE($9, 0),
	def_incorrect_count = term_progress.def_incorrect_count +
		COALESCE($10, 0)
RETURNING id,
	to_char(term_first_reviewed_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as term_first_reviewed_at,
	to_char(term_last_reviewed_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as term_last_reviewed_at,
	term_review_count,
	to_char(def_first_reviewed_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as def_first_reviewed_at,
	to_char(def_last_reviewed_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as def_last_reviewed_at,
	def_review_count,
	term_leitner_system_box, def_leitner_system_box,
	term_correct_count, term_incorrect_count,
	def_correct_count, def_incorrect_count`,
		termID,
		authedUser.ID,
		progress.TermReviewedAt,
		progress.DefReviewedAt,
		progress.TermLeitnerSystemBox,
		progress.DefLeitnerSystemBox,
		progress.TermCorrectIncrease,
		progress.TermIncorrectIncrease,
		progress.DefCorrectIncrease,
		progress.DefIncorrectIncrease,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to update term progress: %w", err)
	}

	return &termProgress, nil
}

// RecordConfusedTerms is the resolver for the recordConfusedTerms field.
func (r *mutationResolver) RecordConfusedTerms(ctx context.Context, confusedTerms []*model.TermConfusionPairInput) (*bool, error) {
	var success bool
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		success = false
		return &success, fmt.Errorf("not authenticated")
	}

	if confusedTerms == nil || len(confusedTerms) == 0 {
		success = false
		return &success, nil
	}

	values := make([]interface{}, 0, len(confusedTerms)*5)
	values = append(
		values,
		*authedUser.ID,
	)
	placeholders := make([]string, 0, len(confusedTerms))

	for i, ct := range confusedTerms {
		placeholders = append(
			placeholders,
			fmt.Sprintf(
				"($1,$%d,$%d,$%d,$%d,$%d)",
				i*5+2, i*5+3, i*5+4, i*5+5, i*5+6,
			),
		)
		values = append(
			values,
			ct.TermID,
			ct.ConfusedTermID,
			ct.AnsweredWith,
			ct.ConfusedCountIncrease,
			ct.ConfusedAt,
		)
	}

	sql := fmt.Sprintf(`INSERT INTO term_confusion_pairs (
	user_id, term_id, confused_term_id, answered_with, confused_count, last_confused_at
) VALUES %s
ON CONFLICT (user_id, term_id, confused_term_id, answered_with)
DO UPDATE SET confused_count = term_confusion_pairs.confused_count + EXCLUDED.confused_count,
	last_confused_at = EXCLUDED.last_confused_at`,
		strings.Join(placeholders, ","),
	)
	_, err := r.DB.Exec(ctx, sql, values...)
	if err != nil {
		success = false
		return &success, fmt.Errorf("failed to insert/update confusion pairs: %w", err)
	}

	success = true
	return &success, nil
}

// RecordPracticeTest is the resolver for the recordPracticeTest field.
func (r *mutationResolver) RecordPracticeTest(ctx context.Context, input *model.PracticeTestInput) (*model.PracticeTest, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	var practiceTest model.PracticeTest
	err := pgxscan.Get(
		ctx,
		r.DB,
		&practiceTest,
		`INSERT INTO practice_tests
	(timestamp, user_id, studyset_id, questions_correct, questions_total, questions)
VALUES (now(), $1, $2, $3, $4, $5)
RETURNING id, timestamp, user_id, studyset_id, questions_correct, questions_total, questions`,
		authedUser.ID,
		input.StudysetID,
		input.QuestionsCorrect,
		input.QuestionsTotal,
		input.Questions,
	)
	if err != nil {
		return nil, fmt.Errorf("database error in RecordPracticeTest: %w", err)
	}

	return &practiceTest, nil
}

// Authed is the resolver for the authed field.
func (r *queryResolver) Authed(ctx context.Context) (*bool, error) {
	authed := auth.AuthedUserContext(ctx) != nil
	return &authed, nil
}

// AuthedUser is the resolver for the authedUser field.
func (r *queryResolver) AuthedUser(ctx context.Context) (*model.AuthedUser, error) {
	return auth.AuthedUserContext(ctx), nil
}

// Studyset is the resolver for the studyset field.
func (r *queryResolver) Studyset(ctx context.Context, id string) (*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)

	var studyset model.Studyset
	var err error
	if authedUser != nil {
		sql := `
			SELECT id, user_id, title, private,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE id = $1 AND (private = false OR (private = true AND user_id = $2))`
		err = pgxscan.Get(ctx, r.DB, &studyset, sql, id, authedUser.ID)
	} else {
		sql := `
			SELECT id, user_id, title, private,
				to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
			FROM public.studysets
			WHERE id = $1 AND private = false`
		err = pgxscan.Get(ctx, r.DB, &studyset, sql, id)
	}
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("studyset not found")
		}
		return nil, fmt.Errorf("failed to fetch studyset: %w", err)
	}

	return &studyset, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var user model.User
	sql := `
		SELECT
			id,
			username,
			display_name,
		FROM auth.users
		WHERE id = $1
	`
	err := pgxscan.Get(ctx, r.DB, &user, sql, id)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	return &user, nil
}

// FeaturedStudysets is the resolver for the featuredStudysets field.
func (r *queryResolver) FeaturedStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM public.studysets
		WHERE private = false
			AND featured = true
		ORDER BY terms_count DESC
		LIMIT $1 OFFSET $2
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch featured studysets: %w", err)
	}

	return studysets, nil
}

// RecentStudysets is the resolver for the recentStudysets field.
func (r *queryResolver) RecentStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM public.studysets
		WHERE private = false
		ORDER BY updated_at DESC
		LIMIT $1 OFFSET $2
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch recent studysets: %w", err)
	}

	return studysets, nil
}

// SearchStudysets is the resolver for the searchStudysets field.
func (r *queryResolver) SearchStudysets(ctx context.Context, q string, limit *int32, offset *int32) ([]*model.Studyset, error) {
	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM public.studysets
		WHERE tsvector_title @@ websearch_to_tsquery('english', $1) AND private = false
		ORDER BY ts_rank(tsvector_title, websearch_to_tsquery('english', $1)) DESC
		LIMIT $2 OFFSET $3
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, q, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to search studysets: %w", err)
	}

	return studysets, nil
}

// MyStudysets is the resolver for the myStudysets field.
func (r *queryResolver) MyStudysets(ctx context.Context, limit *int32, offset *int32) ([]*model.Studyset, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	l := 20
	if limit != nil && *limit > 0 && *limit < 20 {
		l = int(*limit)
	}

	o := 0
	if offset != nil && *offset > 0 {
		o = int(*offset)
	}

	var studysets []*model.Studyset
	sql := `
		SELECT
			id,
			user_id,
			title,
			private,
			to_char(updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MSTZH:TZM') as updated_at
		FROM public.studysets
		WHERE user_id = $1
		ORDER BY updated_at DESC
		LIMIT $2 OFFSET $3
	`
	err := pgxscan.Select(ctx, r.DB, &studysets, sql, authedUser.ID, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch my studysets: %w", err)
	}

	return studysets, nil
}

// User is the resolver for the user field.
func (r *studysetResolver) User(ctx context.Context, obj *model.Studyset) (*model.User, error) {
	if obj.UserID == nil {
		return nil, nil
	}

	return loader.GetUser(ctx, *obj.UserID)
}

// Terms is the resolver for the terms field.
func (r *studysetResolver) Terms(ctx context.Context, obj *model.Studyset) ([]*model.Term, error) {
	if obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermsByStudysetID(ctx, *obj.ID)
}

// TermsCount is the resolver for the terms_count field.
func (r *studysetResolver) TermsCount(ctx context.Context, obj *model.Studyset) (*int32, error) {
	if obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermsCountByStudysetID(ctx, *obj.ID)
}

// PracticeTests is the resolver for the practice_tests field.
func (r *studysetResolver) PracticeTests(ctx context.Context, obj *model.Studyset) ([]*model.PracticeTest, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil || authedUser.ID == nil || obj.ID == nil {
		return nil, nil
	}

	return loader.GetPracticeTestsByStudysetID(ctx, *obj.ID)
}

// Progress is the resolver for the progress field.
func (r *termResolver) Progress(ctx context.Context, obj *model.Term) (*model.TermProgress, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil || authedUser.ID == nil || obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermProgress(ctx, *obj.ID)
}

// TopConfusionPairs is the resolver for the top_confusion_pairs field.
func (r *termResolver) TopConfusionPairs(ctx context.Context, obj *model.Term) ([]*model.TermConfusionPair, error) {
	authedUser := auth.AuthedUserContext(ctx)
	if authedUser == nil || authedUser.ID == nil || obj.ID == nil {
		return nil, nil
	}

	return loader.GetTermTopConfusionPairs(ctx, *obj.ID)
}

// ConfusedTerm is the resolver for the confused_term field.
func (r *termConfusionPairResolver) ConfusedTerm(ctx context.Context, obj *model.TermConfusionPair) (*model.Term, error) {
	return loader.GetTermByID(ctx, *obj.ConfusedTermID)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Studyset returns StudysetResolver implementation.
func (r *Resolver) Studyset() StudysetResolver { return &studysetResolver{r} }

// Term returns TermResolver implementation.
func (r *Resolver) Term() TermResolver { return &termResolver{r} }

// TermConfusionPair returns TermConfusionPairResolver implementation.
func (r *Resolver) TermConfusionPair() TermConfusionPairResolver {
	return &termConfusionPairResolver{r}
}

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type studysetResolver struct{ *Resolver }
type termResolver struct{ *Resolver }
type termConfusionPairResolver struct{ *Resolver }
